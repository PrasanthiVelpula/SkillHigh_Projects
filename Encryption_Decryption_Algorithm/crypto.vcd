$date
	Mon Aug 04 23:25:32 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module crypto_tb $end
$var wire 8 ! decrypted_data [7:0] $end
$var wire 8 " encrypted_data [7:0] $end
$var reg 1 # clk $end
$var reg 1 $ enable $end
$var reg 8 % plain_data [7:0] $end
$var reg 1 & rst $end
$scope module uut $end
$var wire 1 ' clk $end
$var wire 8 ( decrypted_data [7:0] $end
$var wire 1 ) enable $end
$var wire 8 * encrypted_data [7:0] $end
$var wire 8 + key [7:0] $end
$var wire 8 , plain_data [7:0] $end
$var wire 1 - rst $end
$scope module Keygeneration $end
$var wire 1 ' clk $end
$var wire 1 ) enable $end
$var wire 1 - rst $end
$var reg 8 . keystream [7:0] $end
$var reg 8 / lfsr [7:0] $end
$upscope $end
$scope module enc $end
$var wire 8 0 d_in [7:0] $end
$var wire 8 1 d_out [7:0] $end
$var wire 8 2 key [7:0] $end
$var wire 8 3 rot_out [7:0] $end
$var wire 8 4 sbox_out [7:0] $end
$var wire 8 5 xor_out [7:0] $end
$scope module SBOX $end
$var wire 8 6 d_in [7:0] $end
$var wire 8 7 d_out [7:0] $end
$scope function sbox $end
$var reg 4 8 nibble [3:0] $end
$var reg 4 9 sbox [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module dec $end
$var wire 8 : d_in [7:0] $end
$var wire 8 ; d_out [7:0] $end
$var wire 8 < invsbox_out [7:0] $end
$var wire 8 = key [7:0] $end
$var wire 8 > rot_out [7:0] $end
$scope module INV $end
$var wire 8 ? d_in [7:0] $end
$var wire 8 @ d_out [7:0] $end
$scope function inv $end
$var reg 4 A inv [3:0] $end
$var reg 4 B nibble [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b111 B
b101 A
b1011001 @
b1111111 ?
b10101100 >
b10101100 =
b1011001 <
b0 ;
b1111111 :
b111 9
b101 8
b1111111 7
b1011001 6
b10101100 5
b1111111 4
b1011001 3
b10101100 2
b1111111 1
b0 0
b10101100 /
b10101100 .
1-
b0 ,
b10101100 +
b1111111 *
0)
b0 (
0'
1&
b0 %
0$
0#
b1111111 "
b0 !
$end
#5
b1011001 >
b10110010 <
b10110010 @
b1011 A
b1101 B
b11011100 4
b11011100 7
b11011100 "
b11011100 *
b11011100 1
b11011100 :
b11011100 ?
b1101 9
b1011 8
b10110010 3
b10110010 6
b1011001 5
b0 !
b0 (
b0 ;
b1011001 .
b1011001 +
b1011001 2
b1011001 =
b1011001 /
1$
1)
0&
0-
1#
1'
#10
b10100101 !
b10100101 (
b10100101 ;
b11111100 >
b11111001 <
b11111001 @
b1111 A
b1011 B
b10111111 4
b10111111 7
b10111111 "
b10111111 *
b10111111 1
b10111111 :
b10111111 ?
b1011 9
b1111 8
b11111001 3
b11111001 6
b11111100 5
b10100101 %
b10100101 ,
b10100101 0
0#
0'
#15
b10110011 .
b10110011 +
b10110011 2
b10110011 =
b10110011 /
b111100 !
b111100 (
b111100 ;
b10001111 >
b11111 <
b11111 @
b1 A
b100 B
b1001011 4
b1001011 7
b1001011 "
b1001011 *
b1001011 1
b1001011 :
b1001011 ?
b100 9
b1 8
b11111 3
b11111 6
b10001111 5
b111100 %
b111100 ,
b111100 0
1#
1'
#20
b11111111 !
b11111111 (
b11111111 ;
b1001100 >
b10011000 <
b10011000 @
b1001 A
b1111 B
b11110001 4
b11110001 7
b11110001 "
b11110001 *
b11110001 1
b11110001 :
b11110001 ?
b1111 9
b1001 8
b10011000 3
b10011000 6
b1001100 5
b11111111 %
b11111111 ,
b11111111 0
0#
0'
#25
b1100111 .
b1100111 +
b1100111 2
b1100111 =
b1100111 /
b0 !
b0 (
b0 ;
b1100111 >
b11001110 <
b11001110 @
b1100 A
b1000 B
b10001001 4
b10001001 7
b10001001 "
b10001001 *
b10001001 1
b10001001 :
b10001001 ?
b1000 9
b1100 8
b11001110 3
b11001110 6
b1100111 5
b0 %
b0 ,
b0 0
1#
1'
#30
b1101001 !
b1101001 (
b1101001 ;
b1110 >
b1 A
b100 B
b11100 <
b11100 @
b100 9
b1 8
b1001000 4
b1001000 7
b1001000 "
b1001000 *
b1001000 1
b1001000 :
b1001000 ?
b11100 3
b11100 6
b1110 5
b1101001 %
b1101001 ,
b1101001 0
0#
0'
#35
b10100111 >
b1001111 <
b1001111 @
b100 A
b0 B
b1011 4
b1011 7
b1011 "
b1011 *
b1011 1
b1011 :
b1011 ?
b0 9
b100 8
b1001111 3
b1001111 6
b10100111 5
b1101001 !
b1101001 (
b1101001 ;
b11001110 .
b11001110 +
b11001110 2
b11001110 =
b11001110 /
1#
1'
#40
0#
0'
